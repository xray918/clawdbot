# OpenClaw 沙箱性能分析报告

## 📊 测试总结

**测试环境：**

- 主机: macOS (Apple Silicon)
- Docker: 29.1.3
- 沙箱镜像: `openclaw-sandbox:bookworm-slim` (335MB)
- 测试工具: Python 3
- 测试场景: 文件操作密集型任务 (100个1MB文件)

## 🔬 详细测试数据

### 第一轮完整测试

| 操作类型           | 主机模式   | 沙箱模式   | 性能差距 |
| ------------------ | ---------- | ---------- | -------- |
| **创建 100个文件** | 0.016s     | 0.064s     | **4.0x** |
| **读取 100个文件** | 0.008s     | 0.047s     | **5.6x** |
| **列出目录 100次** | 0.004s     | 0.019s     | **5.2x** |
| **查找文件**       | 0.0001s    | 0.0003s    | 3.7x     |
| **复制 100个文件** | 0.072s     | 0.118s     | **1.6x** |
| **删除所有文件**   | 0.019s     | 0.022s     | **1.2x** |
| **总耗时**         | **0.119s** | **0.269s** | **2.3x** |

### 多轮测试稳定性验证

| 测试轮次 | 主机模式   | 沙箱模式   | 性能差距 |
| -------- | ---------- | ---------- | -------- |
| 第 1 轮  | 0.119s     | 0.269s     | 2.3x     |
| 第 2 轮  | 0.074s     | 0.289s     | 3.9x     |
| 第 3 轮  | 0.115s     | 0.294s     | 2.6x     |
| **平均** | **0.103s** | **0.284s** | **2.8x** |

## 📈 性能分析

### ⚡ 关键发现

1. **文件 I/O 性能差距**: **2-6倍**
   - Docker 的联合文件系统 (overlay2) 引入额外开销
   - 每次文件操作需要经过多层抽象

2. **小文件读写受影响最大**: **4-6倍**
   - 创建文件: 4.0x 慢
   - 读取文件: 5.6x 慢
   - 列出目录: 5.2x 慢

3. **大块操作影响较小**: **1.2-1.6倍**
   - 复制文件: 1.6x 慢
   - 删除文件: 1.2x 慢

4. **整体性能**: **平均 2.8倍 慢**
   - 主机: ~0.1 秒
   - 沙箱: ~0.3 秒
   - 绝对时间差: ~0.2 秒

### 🎯 实际影响评估

#### ✅ **影响很小的场景** (推荐使用沙箱)

```bash
# 场景 1: AI 对话交互
用户: "解释这段代码"
影响: 0ms (无文件操作)
结论: 无性能差异 ✅

# 场景 2: 执行少量命令
用户: "查看系统信息"
影响: <10ms (1-2 次文件读取)
结论: 用户无感知 ✅

# 场景 3: 生成单个文件
用户: "写一个 Python 脚本"
影响: <5ms (写入 1 个小文件)
结论: 几乎无影响 ✅

# 场景 4: 读取配置文件
用户: "检查配置"
影响: <10ms (读取几个文件)
结论: 可忽略 ✅
```

#### ⚠️ **有一定影响的场景** (权衡安全性和性能)

```bash
# 场景 1: 批量文件处理
用户: "批量重命名 50 个文件"
主机: 0.05s
沙箱: 0.15s
额外耗时: 0.1s
结论: 可接受，但用户可能注意到延迟 ⚠️

# 场景 2: 代码仓库操作
用户: "git clone 一个仓库"
主机: 1.0s
沙箱: 2.5s
额外耗时: 1.5s
结论: 明显变慢，建议优化或使用主机模式 ⚠️

# 场景 3: 扫描目录树
用户: "统计代码行数"
主机: 0.2s
沙箱: 0.5s
额外耗时: 0.3s
结论: 有延迟但可用 ⚠️
```

#### ❌ **不推荐沙箱的场景** (性能影响显著)

```bash
# 场景 1: 大规模文件操作
用户: "处理 1000 个图片"
主机: 2s
沙箱: 6s
额外耗时: 4s
结论: 显著影响用户体验，考虑主机模式或优化 ❌

# 场景 2: 数据库操作
用户: "导入 CSV 到数据库"
主机: 5s
沙箱: 15s
额外耗时: 10s
结论: I/O 密集，沙箱不适合 ❌

# 场景 3: 构建/编译项目
用户: "编译 C++ 项目"
主机: 10s
沙箱: 25s
额外耗时: 15s
结论: 大量文件读写，严重影响性能 ❌

# 场景 4: 视频/音频处理
用户: "转换视频格式"
主机: 30s
沙箱: 75s
额外耗时: 45s
结论: 大文件 I/O，不推荐沙箱 ❌
```

## 💡 性能优化建议

### 1️⃣ 混合模式：按场景选择

```json
// 推荐配置：生产环境
{
  "agents": {
    "defaults": {
      "sandbox": {
        "mode": "all", // 默认沙箱
        "scope": "session"
      }
    },
    "list": [
      {
        "id": "public",
        "sandbox": {
          "mode": "all" // 公开 Bot: 强制沙箱
        },
        "tools": {
          "allow": ["read", "write", "list_dir"] // 限制工具
        }
      },
      {
        "id": "admin",
        "sandbox": {
          "mode": "off" // 管理任务: 主机运行
        },
        "channels": {
          "feishu": {
            "dmPolicy": "pairing" // 严格配对控制
          }
        }
      }
    ]
  }
}
```

### 2️⃣ 文件系统优化

```json
// 性能优化配置
{
  "agents": {
    "defaults": {
      "sandbox": {
        "docker": {
          // 使用 tmpfs 提升 I/O 性能（数据仅内存，重启丢失）
          "tmpfs": ["/workspace:rw,size=2g"],

          // 或绑定主机目录（牺牲隔离性）
          "binds": ["/tmp/workspace:/workspace:rw"]
        }
      }
    }
  }
}
```

### 3️⃣ 工作区预热

```bash
# 对于频繁访问的文件，可以预先加载到容器
# 在 setupCommand 中执行
{
  "sandbox": {
    "docker": {
      "setupCommand": "mkdir -p /workspace/cache && cp /path/to/common/files /workspace/cache/"
    }
  }
}
```

### 4️⃣ 使用共享容器（适合小团队）

```bash
# scope: shared - 所有用户共享一个容器
# 优点: 减少容器启动开销，文件系统缓存共享
# 缺点: 用户间无文件隔离

pnpm openclaw config set agents.defaults.sandbox.scope shared
```

## 🔍 性能瓶颈原因分析

### Docker 联合文件系统开销

```
主机写入流程:
应用 → 系统调用 → 文件系统 → 磁盘
耗时: ~0.1ms/操作

沙箱写入流程:
应用 → Docker → overlayfs → 系统调用 → 文件系统 → 磁盘
耗时: ~0.3-0.5ms/操作

额外开销: 2-5倍
```

### 具体原因

1. **联合文件系统层级**
   - 每次写入需要经过 overlay2 的写时复制 (CoW)
   - 读取需要遍历多个镜像层

2. **Docker 守护进程通信**
   - 容器内文件操作需要与 Docker daemon 通信
   - 额外的进程间通信开销

3. **安全检查**
   - Docker 的 seccomp/AppArmor 安全检查
   - 每次系统调用都有额外验证

4. **网络文件系统特性**
   - 某些情况下类似 NFS 的性能特征
   - 小文件操作开销更明显

## 📋 使用建议矩阵

| 场景类型 | 文件操作频率 | 推荐模式 | 理由          |
| -------- | ------------ | -------- | ------------- |
| 对话交互 | 无/极少      | 沙箱 ✅  | 无性能影响    |
| 代码查询 | 少量读取     | 沙箱 ✅  | <10ms 延迟    |
| 文件生成 | 少量写入     | 沙箱 ✅  | <5ms 延迟     |
| 批量操作 | 中等         | 沙箱 ⚠️  | 0.1-0.5s 延迟 |
| 构建编译 | 密集         | 主机 ❌  | 10-60s 延迟   |
| 数据处理 | 极密集       | 主机 ❌  | 显著性能损失  |

## 🎯 最佳实践

### 适合沙箱的使用模式 ✅

```bash
1. AI 对话服务 (飞书/Telegram Bot)
   - 主要是自然语言交互
   - 偶尔文件操作
   - 安全性优先级高
   → 推荐: mode: "all"

2. 代码审查助手
   - 读取源码文件
   - 生成报告
   - 中等 I/O
   → 推荐: mode: "all" + tmpfs 优化

3. 文档生成器
   - 生成 Markdown/PDF
   - 少量写入
   → 推荐: mode: "all"
```

### 不适合沙箱的使用模式 ❌

```bash
1. CI/CD 构建
   - 大量编译操作
   - 频繁文件读写
   → 推荐: mode: "off" + 其他安全措施

2. 数据分析工作流
   - 处理大量 CSV/JSON
   - 数据库导入导出
   → 推荐: mode: "off" + 限制网络访问

3. 媒体处理
   - 视频/音频转码
   - 图片批处理
   → 推荐: mode: "off" + 专用容器
```

## 🔧 监控命令

```bash
# 监控文件 I/O 性能
docker stats $(docker ps -q --filter "name=openclaw-sbx")

# 查看容器文件系统驱动
docker info | grep "Storage Driver"

# 测试容器内 I/O 性能
docker exec <container> dd if=/dev/zero of=/workspace/test.dat bs=1M count=100 oflag=direct

# 对比主机 I/O 性能
dd if=/dev/zero of=/tmp/test.dat bs=1M count=100 oflag=direct
```

## 📚 相关资源

- Docker overlay2 性能: https://docs.docker.com/storage/storagedriver/overlayfs-driver/
- 沙箱配置文档: `docs/gateway/sandboxing.md`
- 性能优化指南: `docs/performance.md` (如有)

## 💬 总结

### 核心结论

1. **性能差距**: 沙箱比主机慢 **2-3倍**（文件操作）
2. **绝对耗时**: 多数场景额外增加 **0.1-0.5秒**
3. **用户感知**: 日常使用**几乎无感**，大规模操作**明显变慢**
4. **推荐策略**:
   - 📱 对外服务: 沙箱 ✅ (安全优先)
   - 🛠️ 内部工具: 按需选择 (性能优先)
   - 🏗️ 构建任务: 主机 ✅ (性能优先)

### 金句

> **"对于 AI 对话服务，沙箱带来的 0.2秒 延迟远比安全漏洞的风险可接受。"**

### 推荐阅读

- 完整测试数据: 见本文档
- 资源占用分析: `sandbox-resources.md`
- 快速命令: `cmd.md`
